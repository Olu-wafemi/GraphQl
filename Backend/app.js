const express= require('express');
const path = require('path')


const moongoose = require('mongoose');
const multer = require('multer')
const { graphqlHTTP } = require('express-graphql') 
const graphqlschema = require('./graphql/schema')
const graphqlresolver = require('./graphql/resolvers')
const auth = require('./middleware/auth')
const { clearImage  } = require('./util/file')

const app = express()


const fileStorage = multer.diskStorage({
    destination: (req,file,cb)=>{
        cb(null, 'images');
    },
    filename:(req,file,cb)=>{
       cb( null, new Date().toISOString() + '-' + file.originalname);
    }
})

const fileFilter = (req,file,cb) =>{
    if( file.mimetype === 'image/png' || 
        file.mimetype==='images/jpg' || 
        file.mimetype==='image/jpeg'){
        cb(null, true);
    } else{
        cb(null, false)
    }
}

const bodyParser = require('body-parser')

const { default: mongoose } = require('mongoose');
const { ConnectionClosedEvent } = require('mongodb');
const { rmdirSync } = require('fs');
const { graphql } = require('graphql');
//Parsing incoming json requests


app.use((req,res,next)=>{
    res.setHeader('Access-Control-Allow-Origin', '*')
    res.setHeader('Access-Control-Allow-Methods', 'GET, POST,PUT, PATCH,DELETE')
    res.setHeader('Access-Control-Allow-Headers', 'Content-Type, Authorization');
    //This is to allow graphql send a succcessful options request to the backend
    if (req.method ==="OPTIONS"){
        return res.sendStatus(200);
    }
    next()
    
});
app.use(bodyParser.json())
//Middleware for image Uploading
app.use(multer({storage: fileStorage, fileFilter: fileFilter}).single('image'))
//Serving the images folder to the frontend



app.use('/images', express.static(path.join(__dirname, 'images')))
app.use(auth);
//Logic for handling images for graphql, this is a res-api end point
app.put('/post-image', (req,res,next)=>{
    if(!req.isAuth){
        throw new Error('Not Authenticated')

    }
    if(!req.file) {
        return res.status(200).json({message: 'No file provided'});
    }
    //Check for the existence of a body field, means an old path was passed with the incoming request
    if(req.body.oldPath){
        //This means a new image was uploaded, with an existing path, so this check helps us to confirm that an old path was passed so we can go ahead to clear the old path
        clearImage(req.body.oldPath);
    }
    return res.status(201).json({message: 'File stored', filePath: req.file.path})

})


app.use('/graphql',graphqlHTTP({
    schema: graphqlschema,
    rootValue: graphqlresolver,
    graphiql:true,
    //Formatting error to my tatste
    customFormatErrorFn(err){
        if (!err.originalError){
            return err; //The error generated by the graphql
        }
        const data = err.originalError.data
        const message = err.message|| ' An error occured'
        const code = err.originalError.code || 500;
        return { message: message, status:code, data: data}


    }
}));




//This middleware collects error from the routes middleware and returns the detail of the error back to the frontend
app.use((error,req,res, next)=>{

    console.log(error);
    const status = error.statusCode || 500;
    const message = error.message
    const data = error.data
    res.status(status).json({message: message, data: data});
 
})




//Parsing incoming json requests
app.use(bodyParser.json())

mongoose.connect(
    'mongodb+srv://EffEmm:Oluwafem4@cluster0.mjz0a.mongodb.net/myFirstDatabase?retryWrites=true&w=majority'
   //'mongodb+srv://Femi:Oluwafem4@cluster0.6kvae.mongodb.net/myFirstDatabase?retryWrites=true&w=majority'
).then(result=>{
    console.log('connected')
    
    app.listen(2020);
    

}
    
).catch(err=> console.log(err)) 



//Logic to clear existing images

